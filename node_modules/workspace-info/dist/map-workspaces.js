"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapWorkspaces = void 0;
var tslib_1 = require("tslib");
var util_1 = require("util");
var path_1 = tslib_1.__importDefault(require("path"));
var name_from_folder_1 = tslib_1.__importDefault(require("@npmcli/name-from-folder"));
var read_package_json_fast_1 = tslib_1.__importDefault(require("read-package-json-fast"));
var glob_1 = tslib_1.__importDefault(require("glob"));
var pGlob = util_1.promisify(glob_1.default);
function appendNegatedPatterns(patterns) {
    var results = [];
    for (var _i = 0, patterns_1 = patterns; _i < patterns_1.length; _i++) {
        var pattern = patterns_1[_i];
        var excl = pattern.match(/^!+/);
        if (excl) {
            pattern = pattern.substr(excl[0].length);
        }
        // strip off any / from the start of the pattern.  /foo => foo
        pattern = pattern.replace(/^\/+/, '');
        // an odd number of ! means a negated pattern.  !!foo ==> foo
        var negate = excl && excl[0].length % 2 === 1;
        results.push({ pattern: pattern, negate: negate });
    }
    return results;
}
function getPatterns(workspaces) {
    var workspacesDeclaration = Array.isArray(workspaces.packages)
        ? workspaces.packages
        : workspaces;
    if (!Array.isArray(workspacesDeclaration)) {
        throw getError({
            message: 'workspaces config expects an Array',
            code: 'EWORKSPACESCONFIG',
        });
    }
    return tslib_1.__spreadArrays(appendNegatedPatterns(workspacesDeclaration), [
        { pattern: '**/node_modules/**', negate: true },
    ]);
}
function isEmpty(patterns) {
    return patterns.length < 2;
}
function getPackageName(pkg, pathname) {
    var name = pkg.name;
    return name || name_from_folder_1.default(pathname);
}
function pkgPathmame(opts) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var cwd = opts.cwd ? opts.cwd : process.cwd();
        return path_1.default.join.apply(null, tslib_1.__spreadArrays([cwd], args));
    };
}
// make sure glob pattern only matches folders
function getGlobPattern(pattern) {
    return pattern.endsWith('/') ? pattern : pattern + "/";
}
function getError(_a) {
    var _b = _a.Type, Type = _b === void 0 ? TypeError : _b, message = _a.message, code = _a.code;
    return Object.assign(new Type(message), { code: code });
}
function reverseResultMap(map) {
    return new Map(Array.from(map, function (item) { return item.reverse(); }));
}
function mapWorkspaces(opts) {
    if (opts === void 0) { opts = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _a, workspaces, patterns, results, seen, getGlobOpts, getPackagePathname, _i, patterns_2, item, matches, _b, matches_1, match, pkg, packageJsonPathname, packagePathname, err_1, name;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!opts || !opts.pkg) {
                        throw getError({
                            message: 'mapWorkspaces missing pkg info',
                            code: 'EMAPWORKSPACESPKG',
                        });
                    }
                    _a = opts.pkg.workspaces, workspaces = _a === void 0 ? [] : _a;
                    patterns = getPatterns(workspaces);
                    results = new Map();
                    seen = new Set();
                    if (isEmpty(patterns)) {
                        return [2 /*return*/, results];
                    }
                    getGlobOpts = function () { return (tslib_1.__assign(tslib_1.__assign({}, opts), { ignore: tslib_1.__spreadArrays((opts.ignore || []), ['**/node_modules/**']) })); };
                    getPackagePathname = pkgPathmame(opts);
                    _i = 0, patterns_2 = patterns;
                    _c.label = 1;
                case 1:
                    if (!(_i < patterns_2.length)) return [3 /*break*/, 10];
                    item = patterns_2[_i];
                    return [4 /*yield*/, pGlob(getGlobPattern(item.pattern), getGlobOpts())];
                case 2:
                    matches = _c.sent();
                    _b = 0, matches_1 = matches;
                    _c.label = 3;
                case 3:
                    if (!(_b < matches_1.length)) return [3 /*break*/, 9];
                    match = matches_1[_b];
                    pkg = void 0;
                    packageJsonPathname = getPackagePathname(match, 'package.json');
                    packagePathname = path_1.default.dirname(packageJsonPathname);
                    _c.label = 4;
                case 4:
                    _c.trys.push([4, 6, , 7]);
                    return [4 /*yield*/, read_package_json_fast_1.default(packageJsonPathname)];
                case 5:
                    pkg = _c.sent();
                    return [3 /*break*/, 7];
                case 6:
                    err_1 = _c.sent();
                    if (err_1.code === 'ENOENT') {
                        return [3 /*break*/, 8];
                    }
                    else {
                        throw err_1;
                    }
                    return [3 /*break*/, 7];
                case 7:
                    name = getPackageName(pkg, packagePathname);
                    if (item.negate) {
                        results.delete(packagePathname);
                        results.delete(name);
                    }
                    else {
                        seen.add(name);
                        results.set(packagePathname, name);
                    }
                    _c.label = 8;
                case 8:
                    _b++;
                    return [3 /*break*/, 3];
                case 9:
                    _i++;
                    return [3 /*break*/, 1];
                case 10: return [2 /*return*/, reverseResultMap(results)];
            }
        });
    });
}
exports.mapWorkspaces = mapWorkspaces;
//# sourceMappingURL=map-workspaces.js.map